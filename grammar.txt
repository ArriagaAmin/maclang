S       ->  I
				|   lambda
I       ->  I Inst 
				|   Inst 
Inst    ->  Action 
				|   Def
Action  ->  VarInst ;
				|   FuncCall ;
				|   Conditional
				|   LoopWhile
				|   LoopFor
Def     ->  UnionDef
				|   RegisterDef
				|   RutineDef

# ======= INSTRUCCIONES SOBRE VARIABLES ======= #
VarInst     ->  VarDef
						|   Assign
VarDef      ->  let VarDefBody  
VarDefBody  ->  Type id OptAssign   
OptAssign   ->  lambda
						|   = RValue 
Assign      ->  LValueExp = RValue
RValue      ->  LValueExp 
						|   Expression 
						|		FuncCall
Expression  ->  Number 
						|   BoolExp 
						|   Array
						|   string
						|   char 

# ======= TIPOS ======= #
# Los colocaremos en orden de menor a mayor precedencia
Type	-> 	Type [ Integer ]
			|		^ Type 	
			|		( Type )
			| 	t

# ======= LVALUES ======= #
# Los colocaremos en orden de menor a mayor precedencia
LValue	->	LValue [ Integer ]
				|		^ LValue 
				|		LValue . id 
				| 	( LValue )
				|		id

# ======= EXPRESIONES NUMERICAS ======= #
# Los colocaremos en orden de menor a mayor precedencia
Number	->	Number + Number
				|		Number - Number
				|		Number * Number
				|		Number / Number
				|		Number % Number
				|		- Number
				|		( Number )
				|		int 
				|		float 
				|		LValue
				|		FuncCall


# ======= EXPRESIONES BOOLEANAS ======= #
# Los colocaremos en orden de menor a mayor precedencia
Bool	->	Bool == Bool 
			|		Bool != Bool 
			|		Bool || Bool 
			|		Bool && Bool 
			|		! Bool 
			|		( Bool )
			|		Number Comp Number 
			|		true 
			|		false 
			|		LValue
			|		FuncCall
Comp  ->  < 
			|   <= 
			|   ==
			|   !=  
			|   >=
			|   >

# ======= ARREGLOS ======= #
Array     ->  [ ArrExp ]
ArrExp    ->  lambda 
					|   ArrElems RValue 
ArrElems	->  lambda 
					|   ArrElems RValue ,

# ======= EXPRESIONES ENTERAS ======= #
# Los colocaremos en orden de menor a mayor precedencia
Integer	->	Integer + Integer
				|		Integer - Integer
				|		Integer * Integer
				|		Integer / Integer
				|		Integer % Integer
				|		- Integer
				|		( Integer )
				|		int 
				|		float 
				|		LValue
				|		FuncCall

# ======= LLAMADAS A FUNCIONES ======= #
FuncCall  ->  id ( ArgsExp )
ArgsExp   ->  lambda
					|   Args RValue
Args      ->  lambda 
					|   Args RValue ,

# ======= DEFINICION DE UNIONES ====== #
UnionDef    ->  union id { UnionBody }
UnionBody	->	Type id ;
					|		UnionBody Type id ;

# ======= DEFINICION DE REGISTROS ====== #
RegisterDef   ->  register id { RegisterBody }
RegisterBody	->  VarDef ; 
							|		RegisterBody VarDef ;

# ======= CONDICIONALES ====== #
Conditional ->  if BoolExp then I OptElsif OptElse end
OptElsif    ->  lambda 
						|   Elsifs elsif BoolExp then I
Elsifs      ->  lambda 
						|   Elsifs elsif BoolExp then I 
OptElse     ->  lambda 
						|   else I 

# ======= BUCLES WHILE ====== #
LoopWhile ->  while BoolExp do I done

# ======= BUCLES FOR ====== #
LoopFor ->  for ( id ; Number ; Number OptStep ) do I done 
OptStep ->  lambda 
				|   ; Number

# ======= DEFINICION DE SUBRUTINAS ====== #
RutineDef   ->  id ( RutineArgs ) OptReturn { Actions }
RutineArgs  ->  lambda 
						|   ArgsDef Type OptRef id OptAssign
ArgsDef     ->  lambda 
						|   ArgsDef Type OptRef id OptAssign
OptRef      ->  lambda 
						|   @
OptReturn   ->  lambda 
						|   => Type
Actions     ->  Action 
						|   Actions Action
