# Comentario de linea.
${
  Comentario
  multi
  linea
}$


# tipos primitivos
let Int i = "aa";                     # Entero inicializado con tipo incorrecto.
let Int j = 1;                        # Entero inicializado y con valor asignado.
let Char c = 'A';                     # Caracter
let Bool b;                           # Booleano
let Float f = 1.5;                    # Flotante
let Int x;                  
let Int y = [x+1,3,x+'c'];              # Asignacion de arreglo a un entero.
let Int q4 = y + (^x            * b); # Asignacion con variable no declarada.
                                      # Dereferenciación de entero.

# ERROR Redefinicion
let Char c;
# ERROR No definido
# q = 1;
# ERROR No es una funcion
# q4();
# ERROR No es un tipo 
# let ^^^c[1] w;

# tipos complejos
## arreglos
let Bool[4] array;
let Int[6] integers = [[1, 1], 2, 42, - 'a']; # Arreglo con tipos incorrectos.
                                              # Operador - con tipo Char invalido.

# Todos los elementos de un arreglo deben ser del mismo tipo.
let Int[6] set_numbers = [[0],   [[0]],   [[[0]], [0]],   [[[[0]], [0]], [[0]], [0]]];

## strings

# TODO: revisar que si se pueda asignar Char[] a String.
let String hello = "world";
let String aja = ['a', 'y', ' ', 'n', 'o'];
let Char[4] ohno = "ohwell";
let Char[3] press = ['F'];

## registros
register registro {
  Int numero = 15;
  Int numero2;
  Int numero3 = 42;
  Int numero4;
}

# uniones
union unio {
  Int entero;
  Bool booleano;
  registro r;
  ^^(^registro[3])[10] rpp;
}

# ERROR No es una variable 
# let Int q42 = unio;
# ERROR No es una funcion 
# unio();

def myfunction(unio U) => Int {
  let Int myInt;
}

# ERROR Redefinicion
# def registro() {}

# ERROR No es una variable
# let unio q69 = myfunction;
# ERROR No es un tipo
# let myfunction wtf;

# Operador >= con Int y Bool invalido.
# Dereferenciación de Int (x).
# Variable no declarada (y).
# Operador <= con Float y String invalido.
if ! True && (42**6 >= False) && ^x   [  ^y ** 4] || press == (array != !!!!!!! (0/0 < hello)) then 
  def a() {}              
  register registro {
    Int numero = 15;
  }
done

let Int ppp; # ~; 

def myfunc(^(^Bool[5]) @ khe, Bool ok, Int a = 1, Char c = 2) => Int { 
  for (i; -100; 0++100; 4) do                 # TODO: este error
    let ^Int z = new Int;                     # TODO: este error
    let Int k;                            
    x = (((((x))))).y + 1 + (x.y).z + ppp;    # Acceder a un Int
    ^x[^y**4] = 1;                            # Dereferenciación de un entero
    ^(x[^(y.z) + ^(z.z) * ^(k.k)]) = 42;  
    ^^^^(((((((((x))))))))) = ^y;              
    ^x.y = 1;                                 
    if (x > 0) then 
      x = x * 2;
    elsif (x < -50) then # ~
      x = x - 8;
    elsif False then 
      let Int a = -1;                                 
    else 
      x = x;
    done 

    while i < 100 do i = i+++1; done
  done

  forget a;

  let Int p;
}

if True then 
  let Int a = 1;                            
  register registro {
    Int numero = 15;
  }
done

myfunc([0,[0,[0]]], 1); # ~
# ~
# 0xcbxb
def A() {
  # B();
  while True do # do
    for (i; 0; 100; 0.1) do
      if 1 < 2 then 
        A();
      done 
    done 
  done
} # 0gfhg